#ifndef DBCCPP_PREPAREDSTATEMENT_H__
#define DBCCPP_PREPAREDSTATEMENT_H__

#include <dbccpp/ResultSet.h>
#include <dbccpp/CountProxy.h>
#include <utilcpp/declarations.h>

#include <string>

#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
  #include <memory>
  #include <type_traits>
  namespace dbc
  {
      namespace stdutil = std;
  }
#else
  #include <boost/smart_ptr/shared_ptr.hpp>
  #include <boost/type_traits.hpp>
  namespace dbc
  {
      namespace stdutil = boost;
  }
#endif

namespace dbc
{

class CountProxy;

/** Interface for representing precompiled SQL statements.
 *
 * A SQL statement is precompiled and stored in a PreparedStatement object.
 * This object can then be used to efficiently execute this statement multiple
 * times.
 *
 * The SQL statement must be a UTF-8 string.
 *
 * @throw DbException
 */
class PreparedStatement
{
    UTILCPP_DECLARE_INTERFACE_ALLOW_CONSTRUCTORS(PreparedStatement)

public:

    typedef stdutil::shared_ptr<PreparedStatement> ptr;

    /** Bind value to the prepared statement at the given index.
     *
     * This interface is low-level, it is adviseable to use the
     * operator<<()-based binding instead where possible.
     *
     * Indexing is 1-based as per SQLite binding API.
     *
     * Uses std::enable_if<> and std::is_pod<> to pass POD types
     * by value and non-POD types by const reference.
     *
     * @throw DbException
     */
    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<std::is_pod<T>::value, void>::type
#else
    typename boost::enable_if<boost::is_pod<T>, void>::type
#endif
    set(int parameterIndex, T val);

    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<!std::is_pod<T>::value, void>::type
#else
    typename boost::disable_if<boost::is_pod<T>, void>::type
#endif
    set(int parameterIndex, const T& val);

    /** Bind null to the prepared statement.
     *
     * @throw DbException
     */
    virtual void setNull(int parameterIndex) = 0;

    /** A convenient ostream-like wrapper around set() for binding values
     * to the prepared statement in one go. E.g. binding values to statement
     *
     *   "SELECT * FROM PERSON WHERE name = ? AND age = ?"
     *
     * would work as follows:
     *
     *   *statement << "Ervin" << 38;
     *
     * Uses std::enable_if<> and std::is_pod<> to pass POD types
     * by value and non-POD types by const reference.
     *
     * Returns the PreparedStatementBinder proxy object, a lightweight
     * temporary binder that should not be used directly.
     *
     * @throw DbException
     */
    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<std::is_pod<T>::value, PreparedStatement&>::type
#else
    typename boost::enable_if<boost::is_pod<T>, PreparedStatement&>::type
#endif
    operator<<(T val)
    { set(++_operator_shift_count, val); return *this; }

    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<!std::is_pod<T>::value, PreparedStatement&>::type
#else
    typename boost::disable_if<boost::is_pod<T>, PreparedStatement&>::type
#endif
    operator<<(const T& val)
    { set(++_operator_shift_count, val); return *this; }

    /** Reset the prepared statement object back to its initial state, ready
     * to be re-executed.
     *
     * Contrary to the intuition of many, any bound variables retain their
     * values.
     *
     * @throw DbException
     */
    void reset()
    {
        _operator_shift_count = 0;
        doReset();
    }

    /** Clear all bound parameters.
     *
     * @throw DbException
     */
    void clear()
    {
        _operator_shift_count = 0;
        doClear();
    }

    /** Execute the SQL query in this PreparedStatement object and return the
     * RecordSet object generated by the query.
     *
     * @return RecordSet object that contains the data produced
     * by the query; never null
     *
     * @throw DbException
     */
    ResultSet::ptr executeQuery()
    {
        _operator_shift_count = 0;
        return doExecuteQuery();
    }

    /** Execute a SQL Data Manipulation or Definition Language statement.
     *
     * Returns instance of a CountProxy that will not evaluate the expensive
     * row count calculation unless it is captured in an int variable.
     *
     * If you need the to evaluate the count, use it as follows:
     *
     *   int count = statement.executeUpdate();
     *
     * otherwise just
     *
     *   statement.executeUpdate();
     *
     * (which will not evaluate the count).
     *
     * @return either (1) the row count for DML statements or (2) 0 for
     * statements that return nothing
     *
     * @throw DbException
     */
    const CountProxy& executeUpdate()
    {
        _operator_shift_count = 0;
        return doExecuteUpdate();
    }

    /** Return the row id of the most recent successful INSERT into the
     * active database. If the insert was made to a table that has a column
     * of type INTEGER PRIMARY KEY then the last value from that column is
     * used, otherwise the internal rowid value .
     *
     * @return last insert row id
     *
     * @throw DbException
     */
    // FIXME: this should be a 64-bit type really
    // FIXME: information is SQLite-specific
    virtual int getLastInsertId() = 0;

    /** Get the underlying SQL statement. */
    virtual const char* getSQL() const = 0;

protected:
    PreparedStatement() :
        _operator_shift_count(0)
    { }

    // NVI for set()
    virtual void setString(int parameterIndex, const std::string& val) = 0;
    virtual void setInt(int parameterIndex, const int& val) = 0;
    virtual void setDouble(int parameterIndex, const double& val) = 0;
    virtual void setBool(int parameterIndex, const bool& value) = 0;

    // NVI for actual operations
    virtual void doReset() = 0;
    virtual void doClear() = 0;
    virtual ResultSet::ptr doExecuteQuery() = 0;
    virtual const CountProxy& doExecuteUpdate() = 0;

private:
    // for tracking how many times operator<<() has been called
    int _operator_shift_count;
};

}

#endif /* DBCCPP_PREPAREDSTATEMENT_H__ */
